#!/bin/bash

# The dotfiles repository
DOTFILES=${DOTFILES:-~/.dotfiles}

# Use Homebrew GNU commands on OS X if available
shopt -s expand_aliases
for command in readlink sed; do
  if which g$command &>/dev/null; then
    alias $command="g$command"
  fi
done

function usage {
  echo "Usage: `basename $0` [options] COMMAND [args]"
  echo
  echo "Options:"
  echo "  -n, --dry-run      Only show changes, without performing them"
  echo "  -v, --verbose      Increase verbosity"
  echo "  -q, --quiet        Suppress all normal output"
  echo "  -f, --force        Assume yes for all questions"
  echo
  echo "Commands:"
  echo "  sync               Update, commit and push"
  echo "  up, update         Update submodules (fetch new commits)"
  echo "  ca, commitall      Commit all changes"
  echo "  init               Install symlinks for all dotfiles"
  echo "  install PATH...    Install symlink for PATH"
  echo "  add PATH...        Add file to repository and replace it with a symlink"
  echo "  *                  Excecute a Git subcommand inside the repository directory"
  echo
  exit 255
}

function msg {
  if [ $QUIET -eq 0 -o $VERBOSE -eq 1 -o "$2" = 1 ]; then
    local msg="${1/$HOME/~}"
    local color=${2:-4}

    if [ -n "$msg" ]; then
      echo $3 " [1;3${color}m>[0m $msg" | sed -r 's/\{\{/[1m/g' | sed -r 's/\}\}/[0m/g'
    else
      echo
    fi
  fi
}

function status {
  msg "$1" 2
}

function ask {
  [ $FORCE -eq 1 ] && return

  msg "$1 [y/N] " "${2:-6}" -n >&2
  read
  [ "$REPLY" = "Y" -o "$REPLY" = "y" ]
}

function ask_yes {
  msg "$1 [Y/n] " "$2" -n >&2
  read
  [ "$REPLY" != "N" -a "$REPLY" != "n" ]
}

function error {
  STATUS=1
  msg "$1" 1
}

function abort {
  STATUS=1
  if ! ask "Do you want to continue?" 1; then
    exit 1
  fi
}

function system {
  local command="$1"
  shift

  if [ "$command" = "chown" -o "$command" = "chgrp" ]; then
    echo "[1m$command[0m requires sudo"
    command="sudo $command"
  else
    for arg in "$@"; do
      local dir=`dirname -- "$arg"`
      if [ -d "$dir" -a ! -w "$dir" ]; then
        echo "not writable: $dir"
        command="sudo $command"
        break
      fi
    done
  fi

  [ $FORCE   -eq 1 ] && command="$command -f"
  [ $VERBOSE -eq 1 ] && command="$command -v" && echo "     executing: $command $@"
  [ $DRYRUN  -eq 1 ]                          && echo "     executing: $command $@ [DRY RUN]" && return

  $command "$@"
}

function git {
  if [ "$1" = "ignore-errors" ]; then
    local onerror=":"
    shift
  else
    local onerror="abort"
  fi

  [ $VERBOSE -eq 1 ] && echo "    executing: git $@"
  [ $DRYRUN  -eq 1 ] && echo "    executing: git $@ [DRY RUN]" && return

  pushd "$DOTFILES" >/dev/null || exit 1
  command git "$@" || $onerror
  local status=$?
  popd >/dev/null

  return $status
}

function validate {
if ! [[ "$1" =~ ^($HOME|(/private|/usr/local)?/etc)($|/) ]]; then
    error "Path is not inside \$HOME or /etc: {{$1}}"
    return 1
  else
    return 0
  fi
}

function target {
  local origin="$1"

  if [[ "$origin" =~ ^$HOME/ ]]; then
    local target="${1:${#HOME}+1}"
  elif [[ "$origin" =~ ^/private/etc/ ]]; then
    local target="${1:8}"
  elif [[ "$origin" =~ ^/usr/local/etc/ ]]; then
    local target="${1:10}"
  elif [[ "$origin" =~ ^/etc/ ]]; then
    local target="${1:1}"
  fi

  echo "$DOTFILES/${target#.}"
}

function origin {
  local target="${1:${#DOTFILES}+1}"
  local topdir="${target%%/*}"

  if [ "$topdir" = "etc" -o "$topdir" = "private" ]; then
    echo "/$target"
  elif [ -e "$HOME/$topdir" ]; then
    echo "$HOME/$target"
  else
    echo "$HOME/.$target"
  fi
}

function run {
  local command="$1"
  local status=0
  shift

  case "$command" in
    checkchanges)
      local changes=`git status -s --ignore-submodules`

      if [ -n "$changes" ]; then
        git status --ignore-submodules
        echo
        abort
        return 0
      else
        return 1
      fi
      ;;
    sync)
      if run checkchanges; then
        msg
        status "{{Committing local changes...}}"
        run commitall
      fi

      msg
      status "{{Merging remote changes...}}"
      run pull

      msg
      status "{{Checking out submodules...}}"
      run submodule sync -q
      run submodule update --init -q

      if git status | grep -q ahead; then
        msg
        status "{{Pushing local changes...}}"
        run push
      fi

      msg
      ;;
    up|update)
      msg
      status "{{Updating submodules...}}"
      run pull -q
      run submodule sync -q
      run submodule foreach git pull origin master
      run commit -m "Update submodules" .gitmodules vim/bundle
      if git status | grep -q "Your branch is ahead"; then
        run push
      fi

      msg
      ;;
    init)
      function install_paths {
        for path in "$@"; do
          if [ ! -e "$path" ]; then
            continue
          fi

          if [ -e "$path/.skip" ]; then
            local status=0
          elif [ -d "$path" -a ! -e "$path/.install" ]; then
            local status=255
          else
            run install "$path"
            local status=$?
          fi

          if [ -d "$path" -a $status -eq 255 ]; then
            install_paths "$path"/*
          fi
        done
      }

      msg
      install_paths "${1:-$DOTFILES}"/*
      msg
      ;;
    install)
      [ $# -eq 0 ] && usage

      for path in "$@"; do
        local origin=`readlink -f -- "$path"`
        local target=`target "$origin"`
        local force=0

        if [[ "$origin" =~ ^$DOTFILES/ ]]; then
          target="$origin"
          origin=`origin "$target"`
        fi

        if [ ! -e "$target" ]; then
          error "Path not found: {{$target}}"
          continue
        elif ! validate "$origin"; then
          continue
        elif [ -L "$origin" ]; then
          local link=`readlink "$origin" 2>/dev/null`
          if [ ! -e "$link" ]; then
            error "Broken symlink: {{$origin}} -> [1;36m$link[0m"
            force=1
          elif [[ "$link" =~ ^$DOTFILES/ ]]; then
            msg "Already symlinked: {{$origin}}"
            continue
          else
            msg "Already symlinked: {{$origin}} -> [1;36m$link[0m"
          fi
        fi

        if [ -e "$origin" -o -L "$origin" ]; then
          local ask="ask"
          local question="Delete {{$origin}} and install symlink?"
        else
          local ask="ask_yes"
          local question="Install symlink for {{$origin}}?"
        fi

        if [ $force -eq 1 ] || $ask "$question"; then
          if [ -d "$origin" ]; then
            if ask "Delete {{$origin}}?"; then
              system rm -r "$origin"
            else
              abort
            fi
          elif [ -e "$origin" -o -L "$origin" ]; then
            system rm "$origin"
          fi

          local parent=`dirname "$origin"`
          if [ ! -d "$parent" ]; then
            system mkdir -p "$parent"
          fi

          if [ ! -e "$origin" -o $DRYRUN -eq 1 ] && system ln -s "$target" "$origin"; then
            status "Successfully installed {{$origin}}"
          else
            error "Error while installing {{$origin}}"
            continue
          fi
        else
          # Path wasn't installed, try the children instead
          status=255
        fi
      done
      ;;
    add)
      [ $# -eq 0 ] && usage

      for path in "$@"; do
        local origin=`readlink -f "$path" 2>/dev/null`
        local target=`target "$origin"`
        local target_dir=`dirname "$target"`

        if [ ! -e "$origin" ]; then
          error "Path not found: {{$origin}}"
        elif ! validate "$origin"; then
          continue
        elif [ -L "$path" ]; then
          msg "Already symlinked: {{$path}}"
          continue
        elif [ -e "$target" ]; then
          run install "$target" "$origin"
          continue
        fi

        ask_yes "Add {{$origin}} to repository?" || continue

        if (test -d "$target_dir" || system mkdir -p "$target_dir") \
          && system mv "$origin" "$target" \
          && system ln -s "$target" "$origin"
        then
          system rm -f "$target_dir/.skip"
          [ -O "$target" ] || system chown "$USER:$GROUPS" "$target"
          [ -d "$target" ] && system chmod g+s "$target"
          git add "$target"

          status "Successfully added {{$target}}"
          let added++
        else
          error "Error while converting path: {{$origin}}"
          continue
        fi
      done
      ;;
    ca|commitall)
      git ignore-errors add -A .
      git ignore-errors commit -a -m "Sync dotfiles" "$@"
      ;;
    pull)
      if run checkchanges; then
        changes=1
      else
        unset changes
      fi

      [ -n "$changes" ] && git stash save | grep -q "No local changes to save" && unset changes
      git pull -v --progress "$@"
      [ -n "$changes" ] && git stash pop -q
      ;;
    push)
      local key=~/.ssh/id_rsa
      if [ -f "$key" -a "`uname -s`" != "Darwin" ]; then
        ssh-add -l | fgrep -q "/.ssh/id_rsa (RSA)" || ssh-add "$key" </dev/null
      fi
      git push -v --progress "$@"
      ;;
    *)
      git ignore-errors $command "$@"
      ;;
  esac

  return $status
}

DRYRUN=0
VERBOSE=0
QUIET=0
FORCE=0
COMMAND=

if [ ! -d "$DOTFILES" ]; then
  error "Dotfiles not found in {{$DOTFILES}}"
  exit 1
fi

# Parse arguments
while [ $# -gt 0 ]; do
  case "$1" in
    -n|--dry-run) DRYRUN=1;;
    -v|--verbose) VERBOSE=1;;
    -q|--quiet)   QUIET=1;;
    -f|--force)   FORCE=1;;
    -*)           usage;;
    *)
      COMMAND=( "$@" )
      break
      ;;
  esac
  shift
done

if [ -n "$COMMAND" ]; then
  STATUS=0
  run "${COMMAND[@]}"
  exit $STATUS
else
  usage
fi
