#!/usr/bin/ruby

require 'yaml'
require 'fileutils'

%w[ xwininfo xprop xwit ].each do |command|
  unless system("which #{command} &>/dev/null")
    puts "Sorry, can't find the '#{command}' command."
    exit 1
  end
end

class Xtile
  Screen = {}

  TILING_MODES = {
    :maximize => lambda {},

    :left => lambda {
      return :width => Screen[:width] / 2 - 8
    },

    :right => lambda {
      return :width  => Screen[:width] / 2,
             :x      => Screen[:x] + Screen[:width] / 2
    },

    :top => lambda {
      return :height => Screen[:height] / 2
    },

    :bottom => lambda {
      return :height => Screen[:height] / 2,
             :y      => Screen[:y] + Screen[:height] / 2
    },

    :center => lambda {
      return :width  => (Screen[:width] * 2 / 3.0).round,
             :height => Screen[:height] - 2 * Screen[:y],
             :x      => Screen[:width] / 2 - (Screen[:width] * 2 / 3.0).round / 2,
             :y      => Screen[:y] * 2
    },

    :topleft => lambda {
      return :width  => Screen[:width] / 2,
             :height => Screen[:height] / 2 - 14
    },

    :topright => lambda {
      return :width  => Screen[:width] / 2,
             :height => Screen[:height] / 2 - 14,
             :x      => Screen[:x] + Screen[:width] / 2
    },

    :bottomleft => lambda {
      return :width  => Screen[:width] / 2,
             :height => Screen[:height] / 2 - 14,
             :y      => Screen[:y] + Screen[:height] / 2
    },

    :bottomright => lambda {
      return :width  => Screen[:width] / 2,
             :height => Screen[:height] / 2 - 14,
             :x      => Screen[:x] + Screen[:width] / 2,
             :y      => Screen[:y] + Screen[:height] / 2 + 14
    },
  }

  WINDOWS = {}
  CONTROL = "#{ENV['HOME']}/.xtile.control"
  CONFIG = "#{ENV['HOME']}/.xtile.conf"

  def self.tile(message)
    run
    pipe.puts message
  end

  def self.running?
    File.exists? CONTROL
  end

  def self.run
    return false if running?

    if fork
      sleep 0.2
      return true
    end

    Screen.merge! screen_config

    at_exit { stop }

    begin
      while mode = pipe.gets.strip
        perform_tile mode
      end
    ensure
      stop
    end
  end

  def self.stop
    FileUtils.rm_f CONTROL
  end

private

  def self.window_id
    `xprop -root _NET_ACTIVE_WINDOW`.strip.sub(/.*(0x\w+),.*/, '\1')
  end

  def self.window_size(id)
    if id == :root
      id = '-root'
    else
      id = "-id #{id}"
    end

    data = `xwininfo #{id} | awk '/Absolute upper-left X:|Absolute upper-left Y:/ { print $4 } /Width:|Height:/ { print $2 }'`.split("\n").map(&:to_i)

    return :x => data[0],
           :y => data[1],
           :width => data[2],
           :height => data[3]
  end

  def self.pipe
    unless @pipe
      puts "opening pipe"
      `mkfifo "#{CONTROL}"` unless File.exists? CONTROL
      @pipe = open(CONTROL, 'r+')
    end

    @pipe
  end

  def self.screen_config
    if File.exists? CONFIG
      config = YAML.load_file CONFIG
      config.is_a?(Hash) ? config : nil
    else
      screen = window_size(:root)
      return :width  => screen[:width],
             :height => screen[:height],
             :x      => 0,
             :y      => 0
    end
  end

  def self.perform_tile(mode)
    if mode.empty? or !options = TILING_MODES[mode.to_sym]
      puts "Invalid tiling mode '#{mode}'"
      return false
    end

    id = window_id
    current_options = window_size(id)
    options = Screen.merge(options.call || {})

    unless window = WINDOWS[id]
      window = WINDOWS[id] = {}
    end

    # Check if the mode has changed
    same_mode = window[:state] == mode

    # Check if the window is already in it's target position
    same_position = !current_options.detect do |key, value|
      (value - options[key].to_i).abs > 50
    end

    # Check if the window was moved from its previous target position
    position_changed = !window[:previous] || (same_mode && current_options.detect do |key, value|
      (value - window[:previous][key].to_i).abs > 50
    end)

    if same_mode and same_position and window[:previous]
      options = window[:options] = window[:previous]
    elsif position_changed
      window[:previous] = current_options
    end

    window[:state] = mode
    window[:options] = options

    system("xwit -id #{id} -move #{options[:x]} #{options[:y]} -resize #{options[:width]} #{options[:height]}")
    system("xwit -id #{id} -sync -focus -warp #{options[:width] / 2} #{options[:height] / 2}")
  end
end

Xtile.tile ARGV[0] || 'maximize'
