#!/usr/bin/ruby

require 'fileutils'
require 'optparse'
require 'socket'
require 'yaml'

%w[ xwininfo xprop xwit ].each do |command|
  unless system("which #{command} &>/dev/null")
    puts "Sorry, can't find the '#{command}' command."
    exit 1
  end
end

def debug(*args); end

def run
  opts = OptionParser.new

  usage = lambda {
    puts opts
    exit 255
  }

  opts.banner = "Usage: #{File.basename $0} [OPTIONS] MODE"

  opts.separator ""
  opts.separator "Tiling Modes:"

  modes = "  "
  Xtile::TILING_MODES.keys.map(&:to_s).sort.each_with_index do |mode, i|
    if i > 0 and i % 5 == 0
      opts.separator modes
      modes = "  "
    end
    modes << "#{mode}, "
  end
  opts.separator modes

  opts.separator ""
  opts.separator "Other Commands:"
  opts.separator "  stop, restart"
  opts.separator ""
  opts.separator "Options:"

  opts.on '-i', '--id WINDOW_ID', String, "Use specified window instead of current window" do |id|
    @id = id
  end

  opts.on '-v', '--verbose', "Show debug information" do
    def debug(*message)
      message = message.map do |m|
        m.is_a?(String) ? m : m.inspect
      end

      puts "#{File.basename $0}[#{$$}] #{message.join ' '}"
    end
  end

  opts.on '-h', '--help', "Show this message", &usage
  opts.separator ""

  opts.parse!

  case ARGV[0]
  when 's', 'stop':
    unless Xtile.running?
      puts "Xtile daemon is not running."
      exit false
    end

    Xtile.kill_server

    if Xtile.running?
      puts "Couldn't stop Xtile daemon."
      exit true
    else
      puts "Successfully stopped Xtile daemon."
      exit false
    end
  when 'r', 'restart':
    Xtile.kill_server
    Xtile.start_server
    if Xtile.running?
      puts "Successfully restarted Xtile daemon."
      exit true
    else
      puts "Couldn't restart Xtile daemon."
      exit false
    end
  when 'reset':
    windows = Xtile.reset
    puts "Purged #{windows} windows."
    exit true
  when nil:
    usage.call
  else
    Xtile.tile ARGV[0], @id
  end

rescue OptionParser::ParseError => e
  if defined? usage
    puts e.message
    usage.call
  else
    raise e
  end
end

class Xtile
  TILING_MODES = {
    :maximize => lambda {},

    :left => lambda { |s, w|
      return :width => s[:width] / 2
    },

    :right => lambda { |s, w|
      width = s[:width] / 2

      return :width  => width,
             :x      => s[:x] + width
    },

    :top => lambda { |s, w|
      return :height => s[:height] / 2
    },

    :bottom => lambda { |s, w|
      height = s[:height] / 2

      return :height => height,
             :y      => s[:y] + height
    },

    :center => lambda { |s, w|
      width = (s[:width] * 0.8).round

      return :width  => width,
             :height => s[:height] - 0.5 * s[:y],
             :x      => s[:width] / 2 - width / 2,
             :y      => s[:y] * 1.25
    },

    :topleft => lambda { |s, w|
      return :width  => s[:width] / 2,
             :height => s[:height] / 2
    },

    :topright => lambda { |s, w|
      width = s[:width] / 2

      return :width  => width,
             :height => s[:height] / 2,
             :x      => s[:x] + width
    },

    :bottomleft => lambda { |s, w|
      height = s[:height] / 2

      return :width  => s[:width] / 2,
             :height => height,
             :y      => s[:y] + height
    },

    :bottomright => lambda { |s, w|
      width = s[:width] / 2
      height = s[:height] / 2

      return :width  => width,
             :height => height,
             :x      => s[:x] + width,
             :y      => s[:y] + height
    },

    :wideleft => lambda { |s, w|
      return :width => s[:width] * 0.7
    },

    :wideright => lambda { |s, w|
      width = s[:width] * 0.7

      return :width => width,
             :x     => s[:x] + s[:width] - width
    },

  }

  CONFIG = "#{ENV['HOME']}/.xtile.conf"
  SOCKET = "#{ENV['HOME']}/.xtile.sock"

  def self.tile(mode, id=nil)
    if client.send [ mode, id ].join("\t"), 0
      true
    else
      false
    end
  end

  def self.running?
    !!server_pid
  end

  def self.start_server
    return false if running?

    if fork
      return wait_for { running? }
    end

    at_exit { stop_server }

    debug "opening server socket..."
    @socket = UNIXServer.open(SOCKET)

    while client = @socket.accept
      message = client.recvfrom(100).first.strip

      mode, id = message.split "\n"
      perform_tile mode, id
      cleanup
    end
  end

  def self.stop_server
    if running?
      if @socket
        debug "closing server socket..."
        @socket.close unless @socket.closed?
      end

      if @config
        debug "writing configuration to #{CONFIG}..."
        open CONFIG, 'w' do |file|
          file.write @config.to_yaml
        end
      end

      true
    else
      false
    end
  ensure
    FileUtils.rm_f SOCKET
  end

  def self.kill_server
    if pid = server_pid
      debug "killing server..."
      Process.kill 'TERM', pid
      return wait_for { not running? }
    end

    not running?
  end

  def self.reset
    if @config
      debug "purging all stored windows..."
      count = config[:windows].size
      config[:windows] = {}
      count
    else
      return false
    end
  end

private

  def self.output(command)
    `#{command} 2>/dev/null`.strip
  end

  def self.wait_for(&block)
    value = false

    30.times do
      sleep 0.1
      value = block.call
      break if value
    end

    return value
  end

  def self.changed(first, second, error_margin=2)
    return true unless first and second

    first.detect do |key, value|
      diff = (value - second[key].to_i).abs
      diff > error_margin
    end
  end

  def self.server_pid
    if File.exist? SOCKET
      pid = output "lsof -F p '#{SOCKET}'"
      if $?.exitstatus == 0
        pid.sub! /\Ap(\d+).*/m, '\1'
        pid = pid.to_i
      else
        nil
      end
    end
  end

  def self.window_list
    output("xprop -root _NET_CLIENT_LIST").sub(/.*#/, '').strip.split(', ')
  end

  def self.active_window
    output("xprop -root _NET_ACTIVE_WINDOW").sub(/.*(0x\w+),.*/, '\1')
  end

  def self.window_props(id)
    if id == :root
      id = '-root'
    else
      id = "-id #{id}"
    end

    x, y, width, height, bleft, bright, btop, bbottom = output("xwininfo -stats -wm #{id} | awk '
      /Absolute upper-left X:|Absolute upper-left Y:/ { print $4 }
      /Width:|Height:/ { print $2 }
      /Frame extents:/ { print $3; print $4; print $5; print $6 }
    '").split(/\s+/).map(&:to_i)

    props = {
      :width  => width,
      :height => height,
      :x      => x,
      :y      => y,
    }

    if bleft
      props[:x] -= bleft
      props[:y] -= btop

      props[:border] = {
        :left   => bleft,
        :right  => bright,
        :top    => btop,
        :bottom => bbottom,
      }
    end

    props
  end

  def self.client
    @client ||= UNIXSocket.open(SOCKET)
  rescue Errno::ENOENT, Errno::ECONNREFUSED
    stop_server
    start_server
    retry
  end

  def self.config
    unless @config
      @config ||= {}

      if File.exists? CONFIG
        debug "reading configuration from #{CONFIG}..."
        config = YAML.load_file(CONFIG)
        @config = config if config.is_a?(Hash)
      end

      # Set default configuration
      @config[:windows] ||= {}
      @config[:screen] ||= {}
      @config[:screen][:x] ||= 0
      @config[:screen][:y] ||= 0

      # Update screen size
      screen = window_props(:root)
      @config[:screen][:width] = screen[:width]
      @config[:screen][:height] = screen[:height]

      cleanup
    end

    @config
  end

  def self.perform_tile(mode, id=nil)
    mode = mode.to_sym
    id ||= active_window

    if !tiling_function = TILING_MODES[mode]
      debug "invalid tiling mode #{mode.inspect}", "window #{id}"
      return false
    end

    # Get the current window properties
    current_props = window_props(id)

    # Subtract the margin from the screen size
    current_screen = config[:screen].dup
    current_screen[:width]  -= 2 * config[:screen][:x]
    current_screen[:height] -= 2 * config[:screen][:y]

    # Call the tiling function
    props = current_screen.merge(tiling_function.call(current_screen, current_props) || {})

    # Add the window borders
    if border = current_props.delete(:border)
      props[:width]  -= border[:left] + border[:right]
      props[:height] -= border[:bottom] + border[:top]
    end

    window = (config[:windows][id] ||= {})

    # Check if the mode has changed
    same_mode = window[:mode] == mode

    # Check if the window is not in its new target position
    moved_from_target = changed(current_props, props)

    # Check if the window was moved from its last target position
    moved_from_last = changed(current_props, window[:last])

    # Check if the original position of the window has changed
    moved_from_original = !window[:original] || (same_mode && changed(current_props, window[:original]))

    message = "tiling #{mode.inspect}"

    if same_mode and !moved_from_target and window[:original]
      mode = :original
      message = "restoring"
      props = window[:last] = window[:original]

    elsif moved_from_last or moved_from_original
      debug :storing, "window #{id}", current_props
      window[:original] = current_props

    end

    debug message, "window #{id}", props

    window[:mode] = mode
    window[:last] = props

    # Move and resize the window
    system("xwit -id #{id} -move #{props[:x]} #{props[:y]} -resize #{props[:width]} #{props[:height]}")

    # Move the mouse cursor to the center of the window
    system("xwit -id #{id} -sync -focus -warp #{props[:width] / 2} #{props[:height] / 2}")
  end

  def self.cleanup(force=false, cycles=1000)
    if force or !@counter or (@counter -= 1).zero?
      @counter = cycles

      # Purge all windows that don't exist anymore
      windows = config[:windows].keys - window_list
      windows.each { |w| config[:windows].delete w }

      debug "cleanup: kept #{config[:windows].size} windows, purged #{windows.size}"
    end
  end
end

run
