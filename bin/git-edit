#!/usr/bin/env bash

workdir=`echo "$PWD" | sed -r "s|^$HOME|~|"`

# default options
AG="ag --nocolor --smart-case"
GIT="git -c color.ui=always"
GIT_FORMAT="%C(yellow)[%h] %C(white)%s"
GIT_LOG=10

# colors
RESET=$(echo -ne '\e[0m')
WHITE=$(echo -ne '\e[1;37m')
RED=$(echo -ne '\e[1;31m')
GREEN=$(echo -ne '\e[1;32m')
YELLOW=$(echo -ne '\e[1;33m')
CYAN=$(echo -ne '\e[1;36m')
GRAY=$(echo -ne '\e[1;30m')

DARKRED=$(echo -ne '\e[0;31m')
DARKGREEN=$(echo -ne '\e[0;32m')
DARKYELLOW=$(echo -ne '\e[0;33m')
DARKCYAN=$(echo -ne '\e[0;36m')

# cursor movement
COLUMNS=`tput cols`
LINES=`tput lines`

SAVE=$(echo -ne '\e[s')
RESTORE=$(echo -ne '\e[u')
SHOW=$(echo -ne '\e[?25h')
HIDE=$(echo -ne '\e[?25l')

BACK=$(echo -ne '\e[D')
ERASE=$(echo -ne '\e[2K')

function main {
  unset list showall force complete
  unset input pattern selection command
  unset loading

  for arg in "$@"; do
    if [ "${arg:0:1}" = "-" ]; then
      case "$arg" in
        -l|--list)     list=1; shift;;
        -a|--all)      showall=1; shift;;
        -f|--force)    force=1; shift;;
        -c|--complete) complete=1; shift; exec 3>&1; exec 1>&2;;
           --spin)     shift; input="$1"; start_loading; read; stop_loading; exit;;
        -*) usage;;
      esac
    else
      break
    fi
  done

  input="$1"
  shift

  if [ -f "$1" ]; then
    input="$1"
    shift
  elif [[ "$1" =~ ^[0-9]+$ ]]; then
    output_selection=1
    selection="$1"
    shift
  fi

  case "$1" in
    edit|edi|ed|"")
      shift
      command=( sensible-editor "$@" )
      ;;
    diff|dif|di|d)
      shift
      command=( git diff "$@" )
      command_run_each=1
      ;;
    add|ad|a)
      shift
      command=( git add "$2" )
      ;;
    each|eac|ea)
      command_run_each=1
      shift
      ;;
    *)
      command=( "$@" )
      shift $#
      ;;
  esac

  pattern="$input"
  limit=$((LINES - 4))

  # check for trailing numbers
  if echo -n "$pattern" | egrep -q '(^|.*#)[0-9]*$'; then
    # use the given number as the selection
    selection=`echo "$pattern"  | sed -r 's/(^|.*#)([0-9]*)$/\2/'`
    pattern=`echo "$pattern" | sed -r 's/#?[0-9]*$//'`
  fi

  # show all matches if the pattern ends with '!'
  if [ "${pattern:$((${#pattern} - 1))}" = "!" ]; then
    showall=1
    pattern="${pattern:0:$((${#pattern} - 1))}"
  fi

  if [ -z "$input" -a -z "$complete" -a -z "$list" ]; then
    # don't edit files with no arguments
    usage
  elif [ -n "$complete" ]; then
    start_loading
  fi

  if ! is_git; then
    match_files
  elif [ -z "$pattern" ]; then
    match_git_status
    if [ ${#matches[@]} -eq 0 ]; then
      match_git_log
      [ -n "$complete" ] && feed_completion "@$selection"
    fi
  elif [ "${input:0:1}" = "@" ]; then
    commit="$pattern"
    GIT_LOG=0
    while [ "${commit:0:1}" = "@" ]; do
      commit=${commit:1}
      let GIT_LOG+=10
    done
    limit=$GIT_LOG

    match_git_log

    if [ -n "$commit" ]; then
      if [[ "$commit" =~ ^[0-9]{,3}$ ]]; then
        commit=${matches[$commit]}
      fi
      match_git_diff
    fi
  else
    match_files
  fi

  [ -z "$count" ]  && count=${#matches[@]}
  [ $count -eq 0 ] && pretty_matches=

  # expand variables in title
  title=$(echo "$title" | sed -r \
    -e "s|%count|$YELLOW$count$WHITE|g" \
    -e "s|%dir|$CYAN[$workdir]$WHITE|g"
  )

  if [ $count -eq 0 ]; then
    title=" $DARKRED>>>$WHITE $title$RESET"
  else
    title=" $GREEN>>>$WHITE $title$RESET"
  fi

  if [ -n "$showall" ]; then
    limit="$count"
  else
    # trim results to number of lines
    [ $count -lt $limit ] && limit=$count
    [ $limit -le 0 ] && limit=1

    if [ $count -gt $limit ]; then
      mapfile -t pretty_matches < <( output "${pretty_matches[@]:0:$limit}" )
    fi
  fi

  # use the selection if set
  if [ -n "$selection" ]; then
    count=1
    matches=${matches[$((selection - 1))]}
    pretty_matches=${pretty_matches[$((selection - 1))]}
    [ "$type" != "log" ] && completion="$matches"
  fi

  if [ -n "$list" ]; then
    output "${matches[@]}"
  elif [ -n "$complete" ]; then
    stop_loading
    echo -n "$ERASE"

    show_matches

    echo -n " $GREEN>>>$RESET "
    [ $count -gt 0 -a -z "$completion" ] && echo -n "$RED"
    if [ -n "$output_selection" ]; then
      echo -n "$selection"
    else
      echo -n "$input"
    fi
    echo -n "$RESET"

    if [ -n "$completion" ]; then
      feed_completion "$completion"
    fi
  else
    if [ $count -eq 0 -o "$type" = "log" ]; then
      show_matches
      return
    elif [ $count -eq 1 -o -z "$showall" ]; then
      matches=${matches[0]}
      if [ "${command[0]}" = "sensible-editor" ]; then
        echo -e " $GREEN>>>$WHITE Editing $GREEN$matches$WHITE"
      else
        echo -e " $GREEN>>>$WHITE Running $CYAN'${command[@]}'$WHITE on $GREEN$matches$WHITE"
      fi

      "${command[@]}" "$matches"
    else
      if [ -z "$force" ]; then
        if [ "${command[0]}" = "sensible-editor" ]; then
          echo -n " $CYAN>>>$WHITE Edit $YELLOW$count$WHITE files?$RESET [Y/n] "
        else
          echo -n " $CYAN>>>$WHITE Run $CYAN'${command[@]}'$WHITE on $YELLOW$count$WHITE files?$RESET [Y/n] "
        fi

        read
        [ "$REPLY" = "n" -o "$REPLY" = "N" ] && exit
      fi

      if [ -n "$command_run_each" ]; then
        echo "$matches" | while read match; do
          "${command[@]}" "$match"
        done
      else
        "${command[@]}" "${matches[@]}"
      fi
    fi
  fi
}

function usage {
  echo "Usage: git-edit [-l|--list] [-a|--all] [-f|--force] [-c|--complete] INPUT [SELECTION] [each] [COMMAND [ARGS..]]"
  echo
  echo "Options":
  echo "  -l, --list       Output all matches (unformatted)"
  echo "  -a, --all        Show all matches (formatted)"
  echo "  -f, --force      Assume yes for all questions"
  echo "  -c, --complete   Completion mode"
  echo
  echo "Input formats:"
  echo "  @                Show Git log (repeat @ to show more entries)"
  echo "  @NUMBER, @HASH   Show changed files for the selected commit "
  echo "  *                Path or fuzzy match pattern"
  echo
  echo "Fuzzy matching:"
  echo "  .               Expands to .*"
  echo "  /               Expands to .*/"
  echo
  echo "Selection:"
  echo "  INPUT#NUMBER    Append the number to the first argument"
  echo "  INPUT NUMBER    Pass selection as second argument"
  echo
  echo "Commands:"
  echo "  edit            Run 'sensible-editor' (default)"
  echo "  diff            Run 'git diff'"
  echo "  add             Run 'git add'"
  echo
  echo "  *               Run any command on the files"
  echo "  each *          Run command on each file separately"
  echo

  exit 255
}

function is_git {
  git rev-parse &>/dev/null
}

function feed_completion {
  echo "$@" | sed -r 's/ /\\ /g' >&3
}

function pick_line {
  head -n "$1" | tail -n 1
}

function output {
  if [ $# -gt 0 ]; then
    IFS=$'\n'
    echo "$*"
  fi
}

function truncate {
  local length="${1:-$((COLUMNS - 8))}"

  if [ "$2" = "head" ]; then
    sed -r "s/^.{4,}(.{$((length - 4))})$/ ...\1/"
  else
    sed -r "s/^(.{$((length - 4))}).{4,}$/\1.../"
  fi
}

function match_files {
  type="files"

  if [ -f "$pattern" ]; then
    matches="$pattern"
    completion="$pattern"
    return
  fi

  # expand '.' to '.*' and '/' to '.*/
  pattern=`echo "$pattern" | sed -r -e 's#(^|[^\])\.($|[^\*])#\1.*\2#g' -e 's#(^|[^/])/+#\1.*/#g'`
  mapfile -t matches < <($AG . -l --file-search-regex "$pattern" 2>/dev/null | sort)

  count=${#matches[@]}

  if [ $count -gt 0 ]; then
    if [ $count -le $limit ]; then
      local prefix=`output "${matches[@]}" | lines prefix`
      if [ -n "$prefix" -a ${#prefix} -gt ${#input} ] && echo "$prefix" | egrep -q "$pattern"; then
        completion="$prefix"
        pattern="$prefix"
      fi
    fi

    mapfile -t pretty_matches < <(
      output "${matches[@]}" \
        | truncate "" head \
        | sed -r "s#($pattern)#$RED\1$RESET#g" \
        | sed -r "s/$/$RESET/"
    )

    title="Found %count matches in %dir"
  else
    title="${RED}No matches in %dir"
  fi
}

function match_git_status {
  type="status"
  mapfile -t pretty_matches < <($GIT status -s | grep -vP '^[^a-z]+mD\e')
  mapfile -t matches < <(output "${pretty_matches[@]}" | sed -r 's/.* ([^ ]+)$/\1/')

  if [ ${#matches[@]} -gt 0 ]; then
    title="Found %count changes in %dir"
  else
    title="No changes in %dir"
  fi
}

function match_git_log {
  type="log"
  local log="$GIT log -n $GIT_LOG --all --no-merges"
  mapfile -t matches < <($log --pretty=format:"%h")

  if [ -n "$matches" ]; then
    mapfile -t pretty_matches < <($log --pretty=format:"$GIT_FORMAT" | truncate $((COLUMNS + 2)))
    title="Latest commits in %dir"
  else
    title="No commits in %dir"
  fi
}

function match_git_diff {
  type="diff"
  local diff="$GIT diff-tree -r --stat --no-commit-id ${commit:-HEAD}"
  mapfile -t matches < <($diff --name-only 2>/dev/null)

  if [ $? -ne 0 ]; then
    title="Unknown or ambiguous commit $YELLOW[$commit]$WHITE"
  elif [ -n "$matches" ]; then
    mapfile -t pretty_matches < <($diff --color | fgrep '|' | sed -r 's/^\s*//')
    title=`$GIT show $commit -s --pretty=format:"$GIT_FORMAT" | truncate`
  else
    title="No changed files in commit $YELLOW[$commit]$WHITE"
  fi
}

function show_matches {
  if [ $count -eq 1 ] && [ -n "$selection" -o "$type" = "files" ]; then
    return
  fi

  echo
  echo -n "$title "
  echo -n "$GRAY[$type"
  [ $count -eq 0 -a -n "$input" ] && echo -n "~$input" | truncate 20 head
  echo "]$RESET"

  if [ $count -gt 0 -o "$type" = "log" ]; then
    output "${pretty_matches[@]}" | nl -s ' ' | sed -r "s/^\s{2}(\s*)([0-9]+)/ \1$DARKYELLOW[$YELLOW\2$DARKYELLOW]$RESET/"

    if [ $count -gt $limit -a -z "$showall" ]; then
      echo "         $GRAY($RESET$((count - limit))$GRAY more...)$RESET"
    fi
  fi
}

function start_loading {
  if [ -v __GIT_EDIT_LAST ]; then
    [ -n "$complete" ] && echo
    echo -n "$SAVE"
    echo -n " $GREEN>>>$RED "

    if [ -n "$input" ]; then
      echo -n "$input "
    fi
  elif [ -n "$input" ]; then
    echo -n " "
  fi

  echo -n "$HIDE$RED"

  (
    while true; do
      for char in ◐ ◓ ◑ ◒; do
        echo -n "$char$BACK"
        sleep 0.1
      done
    done
  ) 2>/dev/null &

  loading=$!
  trap "stop_loading; exit" 0 1 2 3 9 15
}

function stop_loading {
  if [ -n "$loading" ]; then
    kill -9 $loading 2>/dev/null
    [ -v __GIT_EDIT_LAST ] && echo -n "$RESTORE"
    echo -n "$RESET$SHOW"
    unset loading
  fi
}

main "$@"
