" Initialisation
" {{{

  set nocompatible

  let s:has_ag  = executable('ag')
  let s:has_ack = executable('ack')

  " set up pathogen
  runtime bundle/pathogen/autoload/pathogen.vim
  let g:pathogen_disabled = []

  " session doesn't work with minibufexpl
  call add(g:pathogen_disabled, 'session')

  " neocomplete requires Vim 7.3 and Lua
  if v:version < '703' || !has('lua')
    call add(g:pathogen_disabled, 'neocomplete')
  endif

  " Disable neocomplete for SSH sessions
  if $SSH_CONNECTION != ""
    call add(g:pathogen_disabled, 'neocomplete')
  endif

  " Powerline requires Vim 7.3 and Python
  if v:version < '703' || !has('python')
    call add(g:pathogen_disabled, 'powerline')
  endif

  " load bundles
  call pathogen#infect()

  if has('gui_running')
    " avoid loading the menu, has to be set before loading filetypes
    set guioptions+=M
  end

" }}}

" General Settings
" {{{

  " file handling
  filetype plugin indent on
  set hidden
  set nobackup
  set autowrite
  set encoding=utf-8
  set modeline
  set modelines=2
  if v:version > '703'
    set cryptmethod=blowfish
  end

  " searching
  set ignorecase
  set smartcase
  set incsearch
  set hlsearch

  set directory=~/.vim/tmp/swap//,.,/var/tmp//,/tmp//
  set dictionary=/usr/share/dict/words

  " create temporary directory in ~/.vim/tmp
  let s:tmpdir = expand("~") . "/.vim/tmp"
  if !isdirectory(s:tmpdir)
    call mkdir(s:tmpdir, 'p')
  endif

  " enable persistent undo
  if has('persistent_undo')
    set undofile
    set undodir=~/.vim/tmp/undo

    if !isdirectory(&undodir)
      call mkdir(&undodir, 'p')
    endif
  endif

" }}}

" Display Settings
" {{{

  " interface
  syntax on
  colorscheme desertink
  set lazyredraw
  set errorbells
  set visualbell t_vb= " disable bells
  set synmaxcol=1000 " disable syntax highlighting on really long lines

  " windows
  set splitbelow
  set splitright

  " disable preview window for completion
  set completeopt-=preview

  " buffers
  set number
  set numberwidth=6
  set scrolloff=5
  set sidescrolloff=8
  set sidescroll=1
  set virtualedit+=block
  set nostartofline
  set display+=lastline

  if has('conceal')
    set conceallevel=2
  end

  " command prompt and status line
  set showcmd
  set ruler
  set laststatus=2
  set history=1000
  set report=0
  set wildmenu
  set wildmode=longest:full,full
  set wildignore=*.pyc,*.o,*.lo,*.la,*.exe,*.swp,*.db,*.bak,*.old,*.dat,*.,tmp,*.mdb,*~,~*

  " cursor line
  " autocmd CursorHold *
  "   \ if &buftype != 'quickfix' && bufname('%') != '-MiniBufExplorer-' | setlocal cursorline | endif
  " autocmd CursorMoved,InsertEnter,BufLeave *
  "   \ if &l:cursorline | setlocal nocursorline | endif

  " highlight trailing whitespace
  autocmd VimEnter,Colorscheme * highlight Whitespace ctermbg=235 guibg=#333333
  autocmd VimEnter,Colorscheme * match Whitespace /\s\+$/

  " go to last cursor position when opening files
  autocmd BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$") && &ft != 'gitcommit'
                          \| exe "normal g'\"" | endif

  " window titles
  set title
  if match($TERM, '^screen-') == 0
    set t_ts=k
    set t_fs=\
  endif

  if $STY
    " show filename in screen title
    set titlestring=%t\ %m
  else
    "set titlestring=%r%m\ %t\ \[%{substitute(expand('%:p:h'),\ $HOME,\ '~',\ 'g')}\]\ -\ %{v:servername}
  endif

" }}}

" Text Formatting
" {{{

  set selection=inclusive
  set backspace=indent,eol,start
  set whichwrap+=<,>,[,],h,l

  " indents
  set autoindent
  set smartindent
  set nocindent

  " avoid auto-indenting hash signs
  "inoremap # x<C-H>#

  " tabs
  set noexpandtab
  set smarttab
  set shiftround

  " matching
  set matchpairs=(:),{:},[:],<:>
  set showmatch
  runtime macros/matchit.vim
  let b:match_ignorecase = 1

  " diffing
  "set diffopt+=iwhite

  " folding
  set foldenable foldmethod=marker
  "autocmd Syntax * set foldmethod=marker

" }}}

" Filetype Settings
" {{{

  autocmd FileType alsaconf,applescript,asm,autoit,coffee,context,css,dot,eruby,html,io,javascript,lisp,markdown,ocaml,perl,php,puppet,smarty,sql,plaintex,ruby,scss,sh,svn,tex,text,textile,vb,vim,xhtml,xml,xslt,yaml setlocal ts=2 sts=2 sw=2 expandtab nocindent
  autocmd FileType c,cs,cpp,php setlocal ts=3 sts=3 sw=3 expandtab
  autocmd FileType python,lua,sshconfig setlocal ts=4 sts=4 sw=4 expandtab
  autocmd FileType apache setlocal ts=4 sts=4 sw=4
  autocmd FileType mail setlocal ts=2 sts=2 sw=2 expandtab tw=80 lbr
  autocmd FileType tex,plaintex,context setlocal lbr
  autocmd FileType gitcommit,gitrebase setlocal colorcolumn=50,72
  autocmd FileType crontab setlocal nobackup nowritebackup

  autocmd BufNewFile,BufRead *.md setf markdown
  autocmd BufNewFile,BufRead */bin/*.run setf sh
  autocmd BufNewFile,BufRead *.inc,*.thtml setf php
  autocmd BufNewFile,BufRead *.boo setf python
  autocmd BufNewFile,BufRead Gemfile setf ruby
  autocmd BufNewFile,BufRead ~/.devilspie/* setf lisp
  autocmd BufNewFile,BufRead *.pac setf javascript

  " Ruby syntax highlighting
  let g:ruby_operators = 1

  " Ruby auto-completion
  " let g:rubycomplete_rails = 1
  " let g:rubycomplete_buffer_loading = 1

  " force initialisation of the ruby environment to avoid stack errors
  " if has('ruby')
  "   silent! ruby nil
  " endif

  " PHP syntax highlighting
  let php_htmlInStrings = 1
  let php_baselib = 1
  let php_special_functions = 1
  let php_alt_comparisons = 1
  let php_alt_AssignByReference = 1
  let php_folding = 1

" }}}

" Commands
" {{{

  " Replace a builtin command using cabbrev
  " http://vim.wikia.com/wiki/Replace_a_builtin_command_using_cabbrev
  function! CommandAlias(abbreviation, expansion)
    execute 'cabbrev ' . a:abbreviation . ' <c-r>=getcmdpos() == 1 && getcmdtype() == ":" ? "' . a:expansion . '" : "' . a:abbreviation . '"<CR>'
endfunction
  command! -nargs=+ CommandAlias call CommandAlias(<f-args>)

  CommandAlias E e
  CommandAlias Q Q
  CommandAlias QA qa
  CommandAlias Qa qa
  CommandAlias qA qa
  CommandAlias WQ wq
  CommandAlias Wq wq
  CommandAlias wQ wq

  " diff shortcuts for visual mode
  command! Dg diffget
  command! Dp diffput

  " shortcuts for online searches
  if has('mac')
    let g:open_command = 'open'
  elseif has('unix')
    let g:open_command = 'xdg-open'
  else
    let g:open_command = 'start'
  end
  command! -nargs=+ Google call system(g:open_command.' "https://www.google.com/search?q=<args>"')
  command! -nargs=+ Dict call system(g:open_command.' "http://dict.leo.org/?lp=ende&search=<args>"')
  command! -nargs=+ Wikipedia call system(g:open_command.' "http://en.wikipedia.org/wiki/Special:Search?search=<args>"')

  " shortcut to edit vim config files
  function! VimConfigFileCompletion(A, L, P) " {{{
    let l:dir = getcwd()
    chdir ~/.dotfiles/vim/

    if isdirectory(a:A) && a:A[-1:] != '/'
      let l:arg = a:A.'/'
    else
      let l:arg = a:A
    endif

    let l:values = split(glob(l:arg.'*',), "\n")
    if len(l:values) == 1 && isdirectory(l:values[0])
      let l:values = [ l:values[0].'/' ]
    endif

    execute "chdir ".l:dir
    return l:values
  endfunction " }}}
  command! -nargs=1 -complete=customlist,VimConfigFileCompletion RC edit ~/.dotfiles/vim/<args>

" }}}

" Keybindings
" {{{

  " shortcut for desktop clipboard
  noremap + "+

  " don't use exact searches for */#
  noremap * g*
  noremap # g#

  " repeat command for each line in selection
  xnoremap . :normal .<CR>

  " shortcuts for diff
  nnoremap du :diffupdate<CR>

  " map Ctrl+C to Escape
  inoremap <C-c> <Esc>

  " indent with Tab/Shift+Tab in visual mode
  vmap <Tab> >
  vmap <S-Tab> <

  " reselect visual block after indent
  xnoremap > >gv
  xnoremap < <gv

  " toggle paste mode with F12
  set pastetoggle=<f12>

  " switch buffers with Shift+Tab / Ctrl+Shift+Tab
  noremap <C-Tab> :MBEbn<CR>
  noremap <C-S-Tab> :MBEbp<CR>

  " navigate windows with Ctrl+jkhl
  noremap <C-j> <C-w>j
  noremap <C-k> <C-w>k
  noremap <C-h> <C-w>h
  noremap <C-l> <C-w>l

  " ,q / ,e - toggle quickfix window and location list
  function! GetBufferList()
    redir =>buflist
    silent! ls
    redir END
    return buflist
  endfunction

  function! ToggleList(bufname, pfx)
    let buflist = GetBufferList()
    for bufnum in map(filter(split(buflist, '\n'), 'v:val =~ "'.a:bufname.'"'), 'str2nr(matchstr(v:val, "\\d\\+"))')
      if bufwinnr(bufnum) != -1
        exec(a:pfx.'close')
        return
      endif
    endfor
    if a:pfx == 'l' && len(getloclist(0)) == 0
        echohl ErrorMsg
        echo "Location List is Empty."
        return
    endif
    let winnr = winnr()
    exec(a:pfx.'open')
    if winnr() != winnr
      wincmd p
    endif
  endfunction

  nnoremap <silent> ,q :call ToggleList('Quickfix List', 'c')<CR>
  nnoremap <silent> ,e :call ToggleList('Location List', 'l')<CR>

  " resize quickfix windows to their content, or 20 lines maximum
  function! ResizeWindow(min, max)
    let l:max = min([a:max, &lines / 3])
    execute max([a:min, min([l:max, line('$') + 1])]).'wincmd _'
  endfunction
  autocmd FileType qf call ResizeWindow(2, 20)

  " ,/ and F2 - remove highlighted search
  nnoremap <silent> ,/ :noh<CR>
  nnoremap <silent> <F2> :noh<CR>

  " ,1-9 and ,01-99 - quick buffer switching
  for i in range(1, 9)
    execute "nnoremap <silent>  ," . i . " :b" . i . "<CR>"
  endfor
  for i in range(1, 99)
    execute "nnoremap <silent>  ,0" . i . " :b0" . i . "<CR>"
  endfor

  " ,c - close current window, or delete the buffer if it's the only window
  function! CloseWindowOrBuffer()
    " get number of visible buffers
    let l:buffers = len(filter(range(1, bufnr('$')), 'buflisted(v:val)'))

    if l:buffers > 1 && index(g:pathogen_disabled, 'minibufexpl') == -1
      let l:main_windows = 2
    else
      let l:main_windows = 1
    end

    " detect splits
    if winnr('$') > l:main_windows
      wincmd c
    else
      bd
    endif
  endfunction
  nnoremap <silent> ,c :call CloseWindowOrBuffer()<CR>

  " ,d - open definition in new window
  nmap <silent> ,d <C-w>f

  " ,n - next buffer
  nnoremap <silent> ,n :bnext<CR>

  " ,p - previous buffer
  nnoremap <silent> ,p :bprevious<CR>

  " ,r - reload current buffer
  nnoremap <silent> ,r :edit<CR>

  " ,R - reload vimrc
  nnoremap <silent> ,R :runtime! vimrc gvimrc<CR>:let &ft=&ft<CR>:nohlsearch<CR>

  " ,s - split horizontally
  nnoremap <silent> ,s :split<CR>

  " ,v - split vertically
  nnoremap <silent> ,v :vsplit<CR>

  " ,w - write file
  nnoremap <silent> ,w :write<CR>

  " ,W - clear trailing whitespace
  nnoremap <silent> ,W mw:%s/\s\s*$//e<CR>:nohlsearch<CR>`w:echohl Question<CR>:echo "Trailing whitespace cleared"<CR>:echohl none<CR>

  " ,g - grep the current file
  if s:has_ag
    let &grepprg = "ag --smart-case --nogroup"
  elseif s:has_ack
    let &grepprg = "ack --smart-case --noheading --with-filename --column"
  endif

  function! GrepWrapper(path)
    if a:path == '%' && expand('%') == ''
      echo "Can't grep unsaved file."
      return
    endif

    echohl Question
    let l:pattern = substitute(input("Grep " . (a:path == '%' ? 'buffer' : 'recursive') . ": /", expand('<cword>')), '"', '\"', '')

    if l:pattern != ""
      echohl Question
      echo "/ searching..."
      execute 'silent grep ' . shellescape(l:pattern) . ' ' . a:path . ' /dev/null'

      let l:len = len(getqflist())
      if l:len > 0
        copen
        redraw
        echo l:len l:len == 1 ? "match" : "matches" "found"
      else
        echohl ErrorMsg
        echo "Pattern not found: ".l:pattern
      endif
    endif

    echohl None
  endfunction
  nnoremap <silent> ,g :call GrepWrapper('%')<CR>

  " ,G - grep the current path
  nnoremap <silent> ,G :call GrepWrapper('.')<CR>

  " ,N - toggle line numbers
  function! ToggleLineNumbers() " {{{
    if &number
      set nonumber
    elseif !exists('&relativenumber') || &relativenumber
      set number
    else
      set relativenumber
    endif
  endfunction " }}}
  nnoremap <silent> ,N :call ToggleLineNumbers()<CR>

  " F4 / F5 - change window height
  nnoremap <silent> <F4> <C-w>+
  imap <silent> <F4> <C-o><F4>
  nnoremap <silent> <F5> <C-w>-
  imap <silent> <F5> <C-o><F5>

  " F6 / F7 - change window width
  nnoremap <silent> <F6> <C-w>>
  imap <silent> <F6> <C-o><F6>
  nnoremap <silent> <F7> <C-w><
  imap <silent> <F7> <C-o><F7>

" }}}

" Plugin Settings
" {{{

  " man {{{
  runtime ftplugin/man.vim
  " }}}

  " rails {{{
  hi! link rubyRailsARMethod Statement
  " }}}

  " undotree {{{
  nnoremap <silent> ,u :UndotreeToggle<CR>
  " }}}

  " jedi {{{
  let g:jedi#auto_vim_configuration = 0
  " }}}

  " javascript-libraries-syntax {{{
  let g:used_javascript_libs = 'jquery,requirejs'
  " }}}

  " syntax attributes {{{
  runtime scripts/SyntaxAttr.vim
  nnoremap <silent> ,S :call SyntaxAttr()<CR>
  " }}}

  " session plugin {{{
  let g:session_directory = "~/.vim/tmp/sessions"
  let g:session_autosave = 'yes'
  " }}}

  " unimpaired {{{
  nmap <C-Up> [e
  nmap <C-Down> ]e
  vmap <C-Up> [egv
  vmap <C-Down> ]egv

  nmap <Esc>Oa [e
  nmap <Esc>Ob ]e
  vmap <Esc>Oa [egv
  vmap <Esc>Ob ]egv
  " }}}

  " ragtag {{{
  imap <C-]> <C-x>/
  autocmd User Ragtag silent! iunmap <buffer> <C-v>%
  autocmd User Ragtag silent! iunmap <buffer> <C-v>&
  " }}}

  " gitshade {{{
  let g:GitShade_ColorGradient = 'black_to_red'
  let g:GitShade_ColorWhat = 'bg'
  command! Gshade GitShade
  " }}}

  " indentline {{{
  let g:indentLine_char = '│'
  let g:indentLine_color_term = 235
  let g:indentLine_color_gui = '#333333'
  " }}}

  " colorizer {{{
  let g:colorizer_startup = 0
  if has('gui_running')
    autocmd FileType css,scss silent ColorToggle
  end
  " }}}

  " tabular {{{
  noremap ,a :Tabular /
  noremap ,a, :Tabular /, /l0<CR>
  noremap ,a{ :Tabular /{<CR>
  noremap ,a} :Tabular /}<CR>
  noremap ,a= :Tabular /=<CR>
  noremap ,a> :Tabular /=><CR>
  noremap ,a: :Tabular /:/l0r1<CR>
  " }}}

  " netrw {{{
  let g:netrw_silent = 1
  let g:netrw_ftpmode = 'ascii'
  let g:netrw_longlist = 1
  let g:netrw_winsize = 40
  let g:netrw_altv = 1
  let g:DrChipTopLvlMenu = 'Plugins.'
  if has('unix') && exists("$DISPLAY")
    let g:netrw_browsex_viewer = 'xdg-open'
  endif
  " }}}

  " minibufexplorer {{{
  let g:miniBufExplSplitBelow = 0
  let g:miniBufExplUseSingleClick = 1
  let g:miniBufExplTabWrap = 1
  let g:miniBufExplSetUT = 1

  highlight link MBENormal Comment
  highlight MBEVisibleNormal ctermbg=22 guibg=#265f26
  highlight MBEVisibleActiveNormal cterm=bold ctermbg=28 gui=bold guibg=#368736
  highlight MBEVisibleActiveChanged cterm=bold ctermbg=124 gui=bold guibg=#cc5653
  highlight MBEVisibleChanged ctermbg=88 guibg=#913d3b
  highlight MBEChanged ctermbg=88 guibg=#913d3b
  let g:did_minibufexplorer_syntax_inits = 1
  " }}}

  " syntastic {{{
  let g:syntastic_check_on_open = 1
  let g:syntastic_enable_signs = 1

  let g:syntastic_javascript_checkers = [ 'jshint' ]
  let g:syntastic_php_checkers = [ 'php', 'phpmd' ]
  let g:syntastic_sh_checkers = [ 'sh' ]

  let g:syntastic_puppet_puppetlint_args = '--no-documentation-check'
  let g:systastic_puppet_puppetlint_args = '--no-documentation-check'

  if !&diff
    let g:syntastic_auto_loc_list = 1
    let g:syntastic_auto_jump = 0
  endif

  autocmd User Fugitive let b:syntastic_skip_checks = 1
  " }}}

  " powerline {{{
  if index(g:pathogen_disabled, 'powerline') == -1
    set runtimepath+=~/.dotfiles/vim/bundle/powerline/powerline/bindings/vim

    " terminal tweaks
    if !has('gui_running')
      " {{{
      let g:powerline_theme_overrides__default = {
        \ 'segment_data': {
          \ 'branch': { 'before': "@ " },
          \ 'line_current_symbol': { 'contents': "" },
          \ 'readonly_indicator': { 'args': { 'text': '#'} }
        \ }
      \ }

      let g:powerline_config_overrides = {
        \ "common": {
          \ "dividers": {
            \ "left":  { "hard": " ", "soft": "> " },
            \ "right": { "hard": " ", "soft": " <" }
          \ }
        \ }
      \ }
      " }}}
    end
  end
  " }}}

  " neocomplete {{{
  if index(g:pathogen_disabled, 'neocomplete') == -1
    let g:neocomplete#enable_at_startup = 1
    let g:neocomplete#enable_auto_select = 1
    let g:neocomplete#enable_smart_case = 1
    let g:neocomplete#auto_completion_start_length = 2

    "call neocomplete#custom#source('syntax', 'disabled', 1)
    "call neocomplete#custom#source('syntax', 'disabled_filetypes', { '_' : 1 })

    if !exists('g:neocomplete#sources#omni#input_patterns')
      let g:neocomplete#sources#omni#input_patterns = {}
    endif

    let g:neocomplete#sources#omni#input_patterns.ruby   = '[^. *\t]\.\w*\|\h\w*::'
    let g:neocomplete#sources#omni#input_patterns.python = '[^. \t]\.\w*'
    let g:neocomplete#sources#omni#input_patterns.php    = '[^. \t]->\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'
    let g:neocomplete#sources#omni#input_patterns.c      = '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?'
    let g:neocomplete#sources#omni#input_patterns.cpp    = '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'

    " Recommended key-mappings.
    " <CR>: close popup and save indent.
    inoremap <silent> <CR> <C-r>=neocomplete#smart_close_popup()<CR><CR>
    " <TAB>: completion.
    inoremap <expr> <TAB> pumvisible() ? "\<C-y>" : "\<TAB>"
    " <C-h>, <BS>: close popup and delete backword char.
    inoremap <expr> <C-h> neocomplete#smart_close_popup()."\<C-h>"
    inoremap <expr> <BS>  neocomplete#smart_close_popup()."\<C-h>"
    inoremap <expr> <C-y> neocomplete#close_popup()
    inoremap <expr> <C-e> neocomplete#cancel_popup()
  endif
  " }}}

  " unite {{{
  if index(g:pathogen_disabled, 'unite') == -1
    let g:unite_data_directory = '~/.vim/tmp/unite'
    let g:unite_source_rec_max_cache_files = 5000
    let g:unite_source_file_mru_long_limit = 5000
    let g:unite_source_history_yank_enable = 1

    " speed up recursive file searches
    if s:has_ag
      let g:unite_source_rec_async_command = 'ag -l .'
      let g:unite_source_grep_command = 'ag'
      let g:unite_source_grep_default_opts = '--nocolor --nogroup -S'
      let g:unite_source_grep_recursive_opt = ''
    elseif s:has_ack
      let g:unite_source_rec_async_command = 'ack -f --nofilter'
      let g:unite_source_grep_command = 'ack'
      let g:unite_source_grep_default_opts = '--no-color --no-heading'
      let g:unite_source_grep_recursive_opt = ''
    end

    " sort file results by length
    call unite#custom#source('file', 'sorters', 'sorter_length')
    call unite#custom#source('file_rec/async', 'sorters', 'sorter_length')
    call unite#custom#source('file_mru', 'sorters', 'sorter_length')

    " limit results for recently edited files
    call unite#custom#source('file_mru', 'max_candidates', 10)

    " map our keys in all Unite buffers
    autocmd FileType unite call s:unite_buffer_mappings()

    function! s:unite_buffer_mappings()
      " use ; to leave insert mode
      inoremap <silent><buffer> ; <Esc>

      " use <Tab> to narrow down paths and open files
      nmap <silent><buffer> <Tab> <Plug>(unite_do_default_action)
      imap <silent><buffer> <Tab> <Plug>(unite_do_default_action)

      " use <C-Tab> to choose custom actions
      imap <silent><buffer> <C-Tab> <Plug>(unite_choose_action)

      " use <C-c> to close Unite
      nmap <silent><buffer> <C-c> <Plug>(unite_exit)
      imap <silent><buffer> <C-c> <Plug>(unite_exit)
    endfunction

    " wrapper for default Unite arguments
    function! UniteWrapper(action, arguments)
      return ":\<C-u>Unite -no-split " . a:action . " " . a:arguments . "\<CR>"
    endfunction

    " ,f - open files in the current working directory or project tree
    nnoremap <silent><expr> ,f UniteWrapper('file' . (expand('%') == '' ? '' : ':%:h') . ' file_rec/async:!' . (expand('%') == '' ? '' : ':%:h') . ' file/new' . (expand('%') == '' ? '' : ':'.escape(expand('%:h'), ' ')), '-start-insert')

    " ,b - switch buffers and open most recently edited files
    nnoremap <silent><expr> ,b UniteWrapper('buffer file_mru:all', '-start-insert')

    " ,y - show yank history
    nnoremap <silent><expr> ,y UniteWrapper('history/yank', '')

    " ,t - show file outline
    nnoremap <silent><expr> ,t UniteWrapper('outline', '-start-insert')
  end
  " }}}

" }}}
