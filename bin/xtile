#!/usr/bin/ruby

require 'fileutils'
require 'optparse'
require 'socket'
require 'yaml'

%w[ xwininfo xprop xwit ].each do |command|
  unless system("which #{command} &>/dev/null")
    puts "Sorry, can't find the '#{command}' command."
    exit 1
  end
end

def debug(*args); end

def run
  opts = OptionParser.new

  usage = lambda {
    puts opts
    exit 255
  }

  opts.banner = "Usage: #{File.basename $0} [OPTIONS] MODE"

  opts.separator ""
  opts.separator "Tiling Modes:"

  modes = "  "
  Xtile::TILING_MODES.keys.map(&:to_s).sort.each_with_index do |mode, i|
    if i > 0 and i % 4 == 0
      opts.separator modes
      modes = "  "
    end
    modes << "#{mode}, "
  end
  opts.separator modes

  opts.separator ""
  opts.separator "Options:"

  opts.on '-i', '--id WINDOW_ID', String, "Use specified window instead of current window" do |id|
    @id = id
  end

  opts.on '-v', '--verbose', "Show debug information" do
    def debug(*message)
      message = message.map do |m|
        m.is_a?(String) ? m : m.inspect
      end

      puts "#{File.basename $0}[#{$$}] #{message.join ' '}"
    end
  end

  opts.on '-h', '--help', "Show this message", &usage

  opts.separator ""

  opts.parse!

  if ARGV[0]
    Xtile.tile ARGV[0], @id
  else
    usage.call
  end

rescue OptionParser::ParseError => e
  if defined? usage
    puts e.message
    usage.call
  else
    raise e
  end
end

class Xtile
  Screen = {}

  TILING_MODES = {
    :maximize => lambda {},

    :left => lambda {
      return :width => Screen[:width] / 2 - 8
    },

    :right => lambda {
      return :width  => Screen[:width] / 2,
             :x      => Screen[:x] + Screen[:width] / 2
    },

    :top => lambda {
      return :height => Screen[:height] / 2
    },

    :bottom => lambda {
      return :height => Screen[:height] / 2,
             :y      => Screen[:y] + Screen[:height] / 2
    },

    :center => lambda {
      return :width  => (Screen[:width] * 2 / 3.0).round,
             :height => Screen[:height] - 2 * Screen[:y],
             :x      => Screen[:width] / 2 - (Screen[:width] * 2 / 3.0).round / 2,
             :y      => Screen[:y] * 2
    },

    :topleft => lambda {
      return :width  => Screen[:width] / 2,
             :height => Screen[:height] / 2 - 14
    },

    :topright => lambda {
      return :width  => Screen[:width] / 2,
             :height => Screen[:height] / 2 - 14,
             :x      => Screen[:x] + Screen[:width] / 2
    },

    :bottomleft => lambda {
      return :width  => Screen[:width] / 2,
             :height => Screen[:height] / 2 - 14,
             :y      => Screen[:y] + Screen[:height] / 2
    },

    :bottomright => lambda {
      return :width  => Screen[:width] / 2,
             :height => Screen[:height] / 2 - 14,
             :x      => Screen[:x] + Screen[:width] / 2,
             :y      => Screen[:y] + Screen[:height] / 2 + 14
    },
  }

  WINDOWS = {}
  CONFIG = "#{ENV['HOME']}/.xtile.conf"
  SOCKET = "#{ENV['HOME']}/.xtile.sock"

  def self.tile(mode, id=nil)
    @context = :client
    client.send [ mode, id ].join("\t"), 0
  end

  def self.running?
    !!server_pid
  end

  def self.server_pid
    if File.exist? SOCKET
      pid = `lsof -F p "#{SOCKET}"`
      if $?.exitstatus == 0
        pid.sub! /\Ap(\d+).*/m, '\1'
        pid = pid.to_i
      else
        nil
      end
    end
  end

  def self.start_server
    return false if running?

    if fork
      sleep 0.1
      return true
    end

    @context = :server

    Screen.merge! screen_config

    at_exit { stop_server }

    begin
      debug "opening server socket..."
      socket = UNIXServer.open(SOCKET)

      while client = socket.accept
        message = client.recvfrom(100).first.strip

        mode, id = message.split "\n"
        perform_tile mode, id
      end
    ensure
      stop_server
    end
  end

  def self.stop_server
    if running?
      debug "removing socket..."
      FileUtils.rm_f SOCKET
    end
  end

  def self.kill_server
    if pid = server_pid
      debug "killing server..."
      Process.kill 'TERM', pid
    end
  end

private

  def self.window_id
    `xprop -root _NET_ACTIVE_WINDOW`.strip.sub(/.*(0x\w+),.*/, '\1')
  end

  def self.window_size(id)
    if id == :root
      id = '-root'
    else
      id = "-id #{id}"
    end

    x, y, width, height, bleft, bright, btop, bbottom = `xwininfo -stats -wm #{id} | awk '
      /Absolute upper-left X:|Absolute upper-left Y:/ { print $4 }
      /Width:|Height:/ { print $2 }
      /Frame extents:/ { print $3; print $4; print $5; print $6 }
    '`.split(/\s+/).map(&:to_i)

    return :x      => x - bleft, # subtract window borders
           :y      => y - btop,  #
           :width  => width,
           :height => height
  end

  def self.client
    @client ||= UNIXSocket.open(SOCKET)
  rescue Errno::ENOENT, Errno::ECONNREFUSED
    stop_server
    start_server
    retry
  end

  def self.screen_config
    if File.exists? CONFIG
      debug "reading screen configuration from #{CONFIG}..."
      config = YAML.load_file CONFIG
      config.is_a?(Hash) ? config : nil
    else
      debug "using default screen configuration"
      screen = window_size(:root)
      return :width  => screen[:width],
             :height => screen[:height],
             :x      => 0,
             :y      => 0
    end
  end

  def self.perform_tile(mode, id=nil)
    mode = mode.to_sym
    id ||= window_id

    if !options = TILING_MODES[mode]
      debug "invalid tiling mode #{mode.inspect}", "window #{id}"
      return false
    end

    current_options = window_size(id)
    options = Screen.merge(options.call || {})

    window = (WINDOWS[id] ||= {})

    # Check if the mode has changed
    same_mode = window[:mode] == mode

    # Check if the window is already in its new target position
    same_position = !current_options.detect do |key, value|
      (value - options[key].to_i).abs > 50
    end

    # Check if the window was moved from its last target position
    window_moved = !window[:options] || current_options.detect do |key, value|
      (value - window[:options][key].to_i).abs > 50
    end

    # Check if the normal position of the window has changed
    position_changed = !window[:last] || (same_mode && current_options.detect do |key, value|
      (value - window[:last][key].to_i).abs > 50
    end)

    if same_mode and same_position and window[:last]
      mode = :restoring
      options = window[:options] = window[:last]
    elsif window_moved or position_changed
      debug :storing, "window #{id}", current_options
      window[:last] = current_options
    end

    debug mode, "window #{id}", options

    window[:mode] = mode
    window[:options] = options

    system("xwit -id #{id} -move #{options[:x]} #{options[:y]} -resize #{options[:width]} #{options[:height]}")
    system("xwit -id #{id} -sync -focus -warp #{options[:width] / 2} #{options[:height] / 2}")
  end
end

run
