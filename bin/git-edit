#!/usr/bin/env bash

workdir=`echo "$PWD" | sed -r "s|^$HOME|~|"`

# default options
AG="ag --nocolor --smart-case"
GIT="git -c color.ui=always"
GIT_FORMAT="%C(yellow)[%h] %C(black bold)%ar:%Creset %s"
GIT_LOG=10

# colors
RESET=$(echo -ne '\e[0m')
WHITE=$(echo -ne '\e[1;37m')
RED=$(echo -ne '\e[1;31m')
GREEN=$(echo -ne '\e[1;32m')
YELLOW=$(echo -ne '\e[1;33m')
CYAN=$(echo -ne '\e[1;36m')
GRAY=$(echo -ne '\e[1;30m')

DARKRED=$(echo -ne '\e[0;31m')
DARKGREEN=$(echo -ne '\e[0;32m')
DARKYELLOW=$(echo -ne '\e[0;33m')
DARKCYAN=$(echo -ne '\e[0;36m')

# cursor movement
COLUMNS=`tput cols`
LINES=`tput lines`

SAVE=$(echo -ne '\e[s')
RESTORE=$(echo -ne '\e[u')
SHOW=$(echo -ne '\e[?25h')
HIDE=$(echo -ne '\e[?25l')

BACK=$(echo -ne '\e[D')
ERASE=$(echo -ne '\e[2K')

function main {
  unset list showall force complete
  unset input pattern selection command
  unset loading

  for arg in "$@"; do
    if [ "${arg:0:1}" = "-" ]; then
      case "$arg" in
        -l|--list)     list=1; shift;;
        -a|--all)      showall=1; shift;;
        -f|--force)    force=1; shift;;
        -c|--complete) complete=1; shift; exec 3>&1; exec 1>&2;;
           --spin)     shift; input="$1"; start_loading; read; stop_loading; exit;;
        -*) usage;;
      esac
    else
      break
    fi
  done

  input="$1"
  shift

  if [ -f "$1" ]; then
    input="$1"
    shift
  elif [[ "$1" =~ ^[0-9]+$ ]]; then
    output_selection=1
    selection="$1"
    shift
  fi

  case "$1" in
    edit|edi|ed|"")
      shift
      command=( sensible-editor "$@" )
      ;;
    diff|dif|di|d)
      shift
      command=( git diff "$@" )
      command_run_each=1
      ;;
    add|ad|a)
      shift
      command=( git add "$2" )
      ;;
    each|eac|ea)
      command_run_each=1
      shift
      ;;
    *)
      command=( "$@" )
      shift $#
      ;;
  esac

  pattern="$input"
  limit=$((LINES - 4))

  # check for trailing numbers
  if echo -n "$pattern" | egrep -q '(^|.*#)[0-9]*$'; then
    # use the given number as the selection
    selection=`echo "$pattern"  | sed -r 's/(^|.*#)([0-9]*)$/\2/'`
    pattern=`echo "$pattern" | sed -r 's/#?[0-9]*$//'`
  fi

  # show all matches if the pattern ends with '!'
  if [ "${pattern:$((${#pattern} - 1))}" = "!" ]; then
    showall=1
    pattern="${pattern:0:$((${#pattern} - 1))}"
  fi

  if [ -z "$input" -a -z "$complete" -a -z "$list" ]; then
    # don't edit files with no arguments
    usage
  elif [ -n "$complete" ]; then
    start_loading
  fi

  match_pattern

  [ -z "$count" ]  && count=${#matches[@]}
  [ $count -eq 0 ] && pretty_matches=

  # expand variables in title
  title=$(echo "$title" | sed -r \
    -e "s|%count|$YELLOW$count$WHITE|g" \
    -e "s|%dir|$CYAN[$workdir]$WHITE|g"
  )

  if [ $count -eq 0 ]; then
    title=" $DARKRED>>>$WHITE $title$RESET"
  else
    title=" $GREEN>>>$WHITE $title$RESET"
  fi

  if [ -n "$showall" ]; then
    limit="$count"
  else
    # trim results to number of lines
    [ $count -lt $limit ] && limit=$count
    [ $limit -le 0 ] && limit=1

    if [ $count -gt $limit ]; then
      mapfile -t pretty_matches < <( output "${pretty_matches[@]:0:$limit}" )
    fi
  fi

  # use the selection if set
  if [ -n "$selection" ]; then
    count=1
    matches=${matches[$((selection - 1))]}
    pretty_matches=${pretty_matches[$((selection - 1))]}
    [ "$type" != "log" ] && completion="$matches"
  fi

  if [ -n "$list" ]; then
    output "${matches[@]}"
  elif [ -n "$complete" ]; then
    show_completion
  else
    if [ $count -eq 0 -o "$type" = "log" ]; then
      output "${matches[@]}"
      return
    elif [ $count -eq 1 -o -z "$showall" ]; then
      matches=${matches[0]}
      if [ "${command[0]}" = "sensible-editor" ]; then
        echo -e " $GREEN>>>$WHITE Editing $GREEN$matches$WHITE"
      else
        echo -e " $GREEN>>>$WHITE Running $CYAN'${command[@]}'$WHITE on $GREEN$matches$WHITE"
      fi

      "${command[@]}" "$matches"
    else
      if [ -z "$force" ]; then
        if [ "${command[0]}" = "sensible-editor" ]; then
          echo -n " $CYAN>>>$WHITE Edit $YELLOW$count$WHITE files?$RESET [Y/n] "
        else
          echo -n " $CYAN>>>$WHITE Run $CYAN'${command[@]}'$WHITE on $YELLOW$count$WHITE files?$RESET [Y/n] "
        fi

        read
        [ "$REPLY" = "n" -o "$REPLY" = "N" ] && exit
      fi

      if [ -n "$command_run_each" ]; then
        echo "$matches" | while read match; do
          "${command[@]}" "$match"
        done
      else
        "${command[@]}" "${matches[@]}"
      fi
    fi
  fi
}

function usage {
  if [ -z "$complete" ]; then
    cat <<EOF
Usage: git-edit [OPTIONS] INPUT [SELECTION] [each] [COMMAND [ARGS..]]

Options:
  -l, --list       Output all matches (unformatted)
  -a, --all        Show all matches (formatted)
  -f, --force      Assume yes for all questions
  -c, --complete   Completion mode

Input formats:
  @                Show Git log (repeat @ to show more entries)
  @NUMBER, @HASH   Show changed files for the selected commit
  *                Path or fuzzy match pattern

  Fuzzy matching:
    .               Expands to .*
    /               Expands to .*/

Selection:
  INPUT#NUMBER    Append the number to the first argument
  INPUT NUMBER    Pass selection as second argument
  INPUT!          Show all files

Commands:
  edit            Run 'sensible-editor' (default)
  diff            Run 'git diff'
  add             Run 'git add'

  *               Run any command on the files
  each *          Run command on each file separately

EOF
  fi

  exit 255
}

function is_git {
  git rev-parse &>/dev/null
}

# output a string to the redirected stdout,
# which will cause the input to be replaced by it
function feed_completion {
  echo "$@" | sed -r 's/ /\\ /g' >&3
}

# output array members separated by newlines
function output {
  if [ $# -gt 0 ]; then
    IFS=$'\n'
    echo "$*"
  fi
}

# truncate lines to the given length
function truncate {
  local length="${1:-$((COLUMNS - 8))}"

  if [ "$2" = "head" ]; then
    sed -r "s/^.{4,}(.{$((length - 4))})$/ ...\1/"
  else
    sed -r "s/^(.{$((length - 4))}).{4,}$/\1.../"
  fi
}

# collect matches for the given pattern
function match_pattern {
  if [ -z "$pattern" -a is_git ]; then
    match_git_status
    if [ ${#matches[@]} -eq 0 ]; then
      match_git_log
      [ -n "$complete" ] && feed_completion "@$selection"
    fi
  elif [ "${input:0:1}" = "@" ]; then
    if ! is_git; then
      title="Not a Git repository"
      return
    fi

    commit="$pattern"
    GIT_LOG=0
    while [ "${commit:0:1}" = "@" ]; do
      commit=${commit:1}
      let GIT_LOG+=10
    done

    if [ "${commit:0:1}" = "!" ]; then
      commit=${commit:1}
      GIT_LOG=-1
    fi

    local original_limit=$limit
    limit=$GIT_LOG

    match_git_log

    if [ -n "$commit" ]; then
      if [[ "$commit" =~ ^[0-9]{,5}$ ]]; then
        local commit_selection=$commit
        commit=${matches[$((commit - 1))]}
      fi

      limit=$original_limit
      unset count matches pretty_matches

      if [ -n "$commit" ]; then
        match_git_diff "$commit"
      else
        title="Invalid commit selection '$commit_selection'"
      fi
    fi
  else
    match_files
  fi
}

function match_files {
  type="files"

  if [ -f "$pattern" ]; then
    matches="$pattern"
    completion="$pattern"
    return
  fi

  # expand '.' to '.*' and '/' to '.*/
  pattern=$(
    echo "$pattern" | sed -r -e 's#\.+\**#.*#g' -e 's#/+#.*/#g'
  )

  mapfile -t matches < <($AG . -l --file-search-regex "$pattern" 2>/dev/null | sort)

  count=${#matches[@]}

  if [ $count -gt 0 ]; then
    if [ $count -le $limit ]; then
      local prefix=`output "${matches[@]}" | lines prefix`
      if [ -n "$prefix" -a ${#prefix} -gt ${#input} ] && echo "$prefix" | egrep -q "$pattern"; then
        completion="$prefix"
        pattern="$prefix"
      fi
    fi

    mapfile -t pretty_matches < <(
      output "${matches[@]}" \
        | truncate "" head \
        | sed -r "s#($pattern)#$RED\1$RESET#g" \
        | sed -r "s/$/$RESET/"
    )

    title="Found %count matches in %dir"
  else
    title="${RED}No matches in %dir"
  fi
}

function match_git_status {
  type="status"
  mapfile -t pretty_matches < <($GIT status -s | grep -vP '^[^a-z]+mD\e')
  mapfile -t matches < <(output "${pretty_matches[@]}" | sed -r 's/.* ([^ ]+)$/\1/')

  if [ ${#matches[@]} -gt 0 ]; then
    title="Found %count changes in %dir"
  else
    title="No changes in %dir"
  fi
}

function match_git_log {
  type="log"

  local log="$GIT log -n $GIT_LOG --all --no-merges"
  mapfile -t matches < <($log --pretty=format:"%h")

  if [ -n "$matches" ]; then
    mapfile -t pretty_matches < <($log --pretty=format:"%C(yellow)[%h] %C(black bold)%ar:%Creset %s" | truncate $((COLUMNS + 2)))
    title="Latest commits in %dir"
  else
    title="No commits in %dir"
  fi
}

function match_git_diff {
  type="diff"
  local diff="$GIT diff-tree -r --stat --no-commit-id ${commit:-HEAD}"
  mapfile -t matches < <($diff -z --name-only 2>/dev/null | tr "\0" "\n")

  if [ $? -ne 0 ]; then
    title="Unknown or ambiguous commit $YELLOW[$commit]$WHITE"
  elif [ -n "$matches" ]; then
    mapfile -t pretty_matches < <($diff --color | fgrep '|' | sed -r 's/^\s*//')
    title="%count changes in `$GIT show $commit -s --pretty=format:"%C(yellow)[%h] %s" | truncate`"
  else
    title="No changed files in commit $YELLOW[$commit]$WHITE"
  fi
}

function show_completion {
  stop_loading
  echo -n "$ERASE"

  # don't show matches when a selection is given,
  # or when a file match only returns one result
  if [ $count -ne 1 ] || [ -z "$selection" -a "$type" != "files" ]; then
    echo -ne "\n$title $GRAY[$type"
    # show the pattern when no match was found
    if [ $count -eq 0 -a -n "$pattern" ]; then
      echo -n "~$pattern" | truncate 20 head
    fi
    echo "]$RESET"

    if [ $count -gt 0 ]; then
      output "${pretty_matches[@]}" | nl -s ' ' | sed -r "s/^\s{2}(\s*)([0-9]+)/ \1$DARKYELLOW[$YELLOW\2$DARKYELLOW]$RESET/"

      if [ $count -gt $limit -a -z "$showall" ]; then
        echo "         $GRAY($RESET$((count - limit))$GRAY more...)$RESET"
      fi
    fi
  fi

  # show the completion prompt
  echo -n " $GREEN>>>$RESET "
  [ $count -gt 0 -a -z "$completion" ] && echo -n "$RED"

  if [ -n "$output_selection" ]; then
    # output the selected match
    echo -n "$selection"
  else
    # output the input
    echo -n "$input"
  fi
  echo -n "$RESET"

  if [ -n "$completion" ]; then
    feed_completion "$completion"
  fi
}

function start_loading {
  if [ -v __GIT_EDIT_LAST ]; then
    [ -n "$complete" ] && echo
    echo -n "$SAVE"
    echo -n " $GREEN>>>$RED "

    if [ -n "$input" ]; then
      echo -n "$input "
    fi
  elif [ -n "$input" ]; then
    echo -n " "
  fi

  echo -n "$HIDE$RED"

  (
    while true; do
      for char in ◐ ◓ ◑ ◒; do
        echo -n "$char$BACK"
        sleep 0.1
      done
    done
  ) 2>/dev/null &

  loading=$!
  trap "stop_loading; exit" 0 1 2 3 9 15
}

function stop_loading {
  if [ -n "$loading" ]; then
    kill -9 $loading 2>/dev/null
    [ -v __GIT_EDIT_LAST ] && echo -n "$RESTORE"
    echo -n "$RESET$SHOW"
    unset loading
  fi
}

main "$@"
