#!/bin/bash

unset type matches pretty_matches prefix count
unset list showall complete expand choice commit
dir=`echo "$PWD" | sed -r "s|^$HOME|~|"`

# default Git options
GIT="git -c color.ui=always"
GIT_FORMAT="%C(yellow)[%h] %C(white)%s"
GIT_LOG=10

# colors
RESET=$(echo -ne '\e[0m')
WHITE=$(echo -ne '\e[1;37m')
RED=$(echo -ne '\e[1;31m')
GREEN=$(echo -ne '\e[1;32m')
YELLOW=$(echo -ne '\e[1;33m')
CYAN=$(echo -ne '\e[1;36m')
GRAY=$(echo -ne '\e[1;30m')

# cursor movement
COLUMNS=`tput cols`
LINES=`tput lines`

SAVE=$(echo -ne '\e[s')
RESTORE=$(echo -ne '\e[u')
SHOW=$(echo -ne '\e[?25h')
HIDE=$(echo -ne '\e[?25l')
ERASE=$(echo -ne '\e[2K')
BACK=$(echo -ne '\e[D')

function main {
  for arg in "$@"; do
    if [ "${arg:0:1}" = "-" ]; then
      case "$arg" in
        -l|--list)     list=1; shift;;
        -a|--all)      showall=1; shift;;
        -c|--complete) complete=1; shift; exec 3>&1; exec 1>&2;;
        -*) usage;;
      esac
    else
      break
    fi
  done

  input="$1"
  pattern="$1"
  choice="$2"
  limit=$((LINES - 4))

  if [ -n "$choice" ] && [[ "$choice" =~ [^0-9] ]]; then
    usage
  fi

  # check for trailing numbers
  if echo -n "$pattern" | egrep -q '(^|.*#)[0-9]*$'; then
    # use the given number as the selected choice
    choice=`echo "$pattern"  | sed -r 's/(^|.*#)([0-9]*)$/\2/'`
    pattern=`echo "$pattern" | sed -r 's/#?[0-9]*$//'`

    if [ -z "$pattern" ]; then
      shift
      pattern="$1"
    fi
  fi

  # show all matches if the pattern ends with '!'
  if [ "${pattern:$((${#pattern} - 1))}" = "!" ]; then
    showall=1
    pattern="${pattern:0:$((${#pattern} - 1))}"
  fi

  # show a loading prompt for auto-completion
  if [ -n "$complete" -a -z "$choice" ]; then
    LOADING=1
    echo
    echo
    echo -ne "$SAVE$HIDE"
    echo -n " $GREEN>$WHITE Scanning...  $RESET"

    (
      sleep 0.2
      while true; do
        for char in ▁ ▃ ▄ ▅ ▆ ▇ █ ▇ ▆ ▅ ▄ ▃; do
          echo -ne "$BACK$GREEN$char$RESET"
          sleep 0.05
        done
      done
    ) 2>/dev/null &

    trap "echo -ne \"$RESET$SHOW\"; kill \$! 2>/dev/null; wait \$! 2>/dev/null; exit" 0 1 2 3 9 15
  fi

  if ! is_git; then
    match_files
  elif [ -z "$pattern" ]; then
    match_git_status
    if [ -z "$matches" ]; then
      match_git_log
      [ -n "$complete" ] && feed_completion "@$choice"
    fi
  elif [ "${input:0:1}" = "@" ]; then
    commit="$pattern"
    GIT_LOG=0
    while [ "${commit:0:1}" = "@" ]; do
      commit=${commit:1}
      let GIT_LOG+=10
    done
    limit=$GIT_LOG

    match_git_log

    if [ -n "$commit" ]; then
      if [[ "$commit" =~ ^[0-9]{,3}$ ]]; then
        commit=`echo "$matches" | pick_line $commit`
      fi
      match_git_diff
    fi
  else
    match_files
  fi

  [ -z "$count" ]  && count=`echo "$matches" | grep -c .`
  [ $count -eq 0 ] && pretty_matches=

  # expand variables in title
  title=$(echo "$title" | sed -r \
    -e "s|%count|$YELLOW$count$WHITE|g" \
    -e "s|%dir|$CYAN[$dir]$WHITE|g"
  )

  if [ $count -eq 0 ]; then
    title=" $RED>$WHITE $title$RESET"
  else
    title=" $GREEN>$WHITE $title$RESET"
  fi

  if [ -n "$showall" ]; then
    limit="$count"
  else
    # trim results to number of lines
    [ $count -lt $limit ] && limit=$count
    [ $limit -le 0 ] && limit=1

    if [ $count -gt $limit ]; then
      pretty_matches=`echo -e "$pretty_matches" | head -n $limit`
    fi
  fi

  # select the given choice
  if [ -n "$choice" ]; then
    count=1
    matches=`echo "$matches" | pick_line $choice`
    pretty_matches=`echo "$pretty_matches" | pick_line $choice`
    [ "$type" != "log" ] && expand=1
  fi

  if [ -n "$list" ]; then
    unset choice
    show_matches
  elif [ -n "$complete" ]; then
    if [ -n "$choice" ]; then
      echo
    else
      # clear loading prompt
      kill $! 2>/dev/null
      wait $! 2>/dev/null
      echo -ne "$RESTORE$SHOW"
      echo -ne "$ERASE"
    fi

    show_matches

    echo -ne " $GREEN>>>$RESET $WHITE$input$RESET"

    if [ -n "$expand" ]; then
      feed_completion "$matches"
    elif [ -n "$prefix" ]; then
      feed_completion "$prefix"
    fi
  else
    if [ $count -eq 0 -o "$type" = "log" ]; then
      show_matches
    elif [ $count -eq 1 ]; then
      echo -e " $GREEN>>>$WHITE Editing $GREEN$matches$WHITE"
      sensible-editor "$matches"
    else
      read -p " $CYAN>>>$WHITE Edit $YELLOW$count$WHITE files?$RESET [Y/n] "
      [ "$REPLY" = "n" -o "$REPLY" = "N" ] && exit
      sensible-editor $matches
    fi
  fi
}

function usage {
  echo "Usage: git-edit [-l|--list] [-a|--all] [-c|--complete] [PATTERN] [CHOICE]"
  exit 255
}

function feed_completion {
  echo "$@" >&3
}

function pick_line {
  head -n "$1" | tail -n 1
}

function is_git {
  git rev-parse &>/dev/null
}

function truncate {
  local length="${1:-$((COLUMNS - 8))}"

  sed -r "s/^(.{$((length - 4))}).{4,}$/\1.../"
}

function match_files {
  type="files"

  # expand '.' to '.*' and '/' to '.*/
  pattern=`echo "$pattern" | sed -r -e 's#(^|[^\])\.($|[^\*])#\1.*\2#g' -e 's#(^|[^/])/+#\1.*/#g'`
  matches=`ag -l . --file-search-regex "$pattern" | sort`
  count=`echo "$matches" | grep -c .`

  if [ -n "$matches" ]; then
    if [ $count -le $limit ]; then
      prefix=`echo "$matches" | prefix`
      if [ -n "$prefix" -a ${#prefix} -gt ${#input} ] && echo "$prefix" | egrep -q "$pattern"; then
        pattern="$prefix"
      else
        unset prefix
      fi
    fi

    pretty_matches=`echo "$matches" | truncate | sed -r "s#($pattern)#$RED\1$RESET#g"`
    title="Found %count matches in %dir"
  else
    title="No matches in %dir"
  fi
}

function match_git_status {
  type="status"
  pretty_matches=`$GIT status -s`
  matches=`echo "$pretty_matches" | sed -r 's/.* ([^ ]+)$/\1/'`

  if [ -n "$matches" ]; then
    title="Found %count changes in %dir"
  else
    title="No changes in %dir"
  fi
}

function match_git_log {
  type="log"
  local log="$GIT log -n $GIT_LOG --all"
  matches=`$log --pretty=format:"%h"`

  if [ -n "$matches" ]; then
    pretty_matches=`$log --pretty=format:"$GIT_FORMAT" | truncate $((COLUMNS + 2))`
    title="Latest commits in %dir"
  else
    title="No commits in %dir"
  fi
}

function match_git_diff {
  type="diff"
  local diff="$GIT diff-tree -r --stat --no-commit-id ${commit:-HEAD}"
  matches=`$diff --name-only 2>/dev/null`

  if [ $? -ne 0 ]; then
    title="Unknown or ambiguous commit $YELLOW[$commit]$WHITE"
  elif [ -n "$matches" ]; then
    pretty_matches=`$diff --color | fgrep '|' | sed -r 's/^\s*//'`
    title=`$GIT show $commit -s --pretty=format:"$GIT_FORMAT" | truncate $COLUMNS`
  else
    title="No changes in commit $YELLOW[$commit]$WHITE"
  fi
}

function show_matches {
  [ -n "$choice" -a $count -eq 1 -a "$type" != "log" ] && return

  echo "$title $GRAY[$type]$RESET"

  if [ $count -gt 0 -o "$type" = "log" ]; then
    echo "$pretty_matches" | nl -s ' ' | sed -r "s/^\s{2}(\s*)([0-9]+)/ \1$YELLOW[\2]$RESET/"

    if [ $count -gt $limit -a -z "$showall" ]; then
      echo "         ($((count - limit)) more...)"
    fi
  fi
}

main "$@"
